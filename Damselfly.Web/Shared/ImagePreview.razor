<!--
    Image preview panel - displays an image in full res. To keep the UX nice, the initial image
    is set to the medium thumb (which should load very quickly) and a hidden image loads the
    full-res version - which may need to be generated on the fly. Once that's loaded, the URL
    of the visible image is updated which should update it instantly.
-->
@inject IJSRuntime JsRuntime

@using Damselfly.Core.ImageProcessing

<!--div id="myResult" class="img-zoom-result"></div-->

<div class="damselfly-imagedisplay img-zoom-container">
    <img @key="ImgPreviewKey" src="@ImageUrlHighRes" @onload="ReplaceUrl" style="display:none">
    <img @key="ImgKey" src="@ImageUrl" id="theImage" class="image-fill">
</div>

@code {
    [Parameter]
    public string ImageID { get; set; }

    private string ImgKey => $"prev{ImageID}";
    private string ImgPreviewKey => $"{ImageID}";
    private string ImageUrl { get; set; }
    private string ImageUrlHighRes => $"/thumb/{ThumbSize.ExtraLarge}/{ImageID}";
    // Note - whilst it would be nice to use the original image here for the max
    // detail when zooming, that doesn't work for images which the browser can't
    // render. We could do something like check for the original file extension
    // and see if it's jpg/png/webp though.
    private string ImageUrlZoom => $"/thumb/{ThumbSize.ExtraLarge}/{ImageID}";

    protected override void OnInitialized()
    {
        base.OnInitialized();

        SetupPreload();
    }

    private void SetupPreload()
    {
        ImageUrl = $"/thumb/{ThumbSize.Medium}/{ImageID}";
        StateHasChanged();
    }

    protected override void OnParametersSet()
    {
        SetupPreload();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRuntime.InvokeAsync<string>("imageZoom", "theImage", ImageUrlZoom);

        }
    }

    protected void ReplaceUrl(ProgressEventArgs args)
    {
        ImageUrl = ImageUrlHighRes;
        StateHasChanged();
    }
}