
@using Damselfly.Core.ImageProcessing

@inject ImageService imageService
@inject ThumbnailService thumbService
@inject BasketService basketService
@inject NavigationManager NavigationManager
@inject WordpressService wpService;
@implements IDisposable

<div class="toolwindow">
    @if (images == null)
    {
        <p><em>Loading selection...</em></p>
    }
    else
    {
        <div class="damselfly-selectedimages">
            @if (!images.Any())
            {
                <p><em>No images in basket.</em></p>
            }
            else
            {
                @foreach (var image in images)
                {
                <div class="damselfly-gridimage wrapping-table-mini" @onclick="@(e => { ToggleSelected( e, image ); })">
                    <GridImage CurrentImage=@image NavContext=@NavigationContexts.Basket DisplayFileName=@false ThumbnailSize=ThumbSize.Small />
                </div>
                }
            }
        </div>
    }

    <div class="selection-toolbar">
        @if (images != null && images.Any())
        {
            @if (ShowDownLoadButton)
            {
                <button title="Export basket images" @onclick="@(() => ShowDownloads())" class="btn btn-primary"><i class="fa fa-download" /></button>
            }
            @if (ShowDownLoadButton)
            {
                <button title="Clear Basket" @onclick="@(() => basketService.Clear())" class="btn btn-primary"><i class="fa fa-trash" /></button>
            }
            @if (ShowDownLoadButton)
            {
                <button title="Upload To Wordpress" @onclick="@(() => UploadToWordPress())" class="btn btn-primary"><i class="fab fa-wordpress" /></button>
            }
        }
        <BasketManager />
    </div>
</div>

@code {
    readonly List<Image> images = new List<Image>();
    readonly List<Basket> baskets = new List<Basket>();
    bool AddingBasket { get; set; }
    string NewBasketName { get; set; }

    [Parameter]
    public bool ShowDownLoadButton { get; set; } = true;

    [Parameter]
    public bool ShowTags { get; set; } = true;

    public bool ShowClearButton { get { return images.Any(); } set { } }

    private void SaveBasket()
    {
        basketService.CreateAndSelectNewBasket(NewBasketName);

        AddingBasket = false;
        SelectedImagesChanged();
        StateHasChanged();
    }

    private void CancelAdding()
    {
        AddingBasket = false;
        StateHasChanged();
    }

    private void AddBasket()
    {
        AddingBasket = true;
        StateHasChanged();
    }

    private void BasketChanged(ChangeEventArgs e)
    {
        basketService.LoadBasket(e.Value.ToString());
    }

    private void UploadToWordPress()
    {
        _ = wpService.UploadBasketToWordpress();
    }

    private void ShowDownloads()
    {
        try
        {
            NavigationManager.NavigateTo("/export");
        }
        catch (Exception ex)
        {
            Logging.LogError("Exception: " + ex.Message);
        }
    }

    /// <summary>
    /// Manage the selection state for the grid images. 
    /// </summary>
    /// <param name="e"></param>
    /// <param name="image"></param>
    private Image prevSelection = null;

    private void ToggleSelected(MouseEventArgs e, Image image)
    {
        var watch = new Stopwatch("ToggleSelection");
        if (e.ShiftKey && prevSelection != null)
        {
            // Range selection. 
            var first = images.FindIndex(x => x.ImageId == prevSelection.ImageId);
            var last = images.FindIndex(x => x.ImageId == image.ImageId);

            if (first > last)
            {
                var temp = last;
                last = first;
                first = temp;
            }

            Logging.Log($"Selecting images {first} ({prevSelection.FileName}) to {last} ({image.FileName})");

            for (int i = first; i <= last; i++)
            {
                var img = images[i];
                SelectionService.Instance.SelectImage(img);
            }
        }
        else
        {
            if (e.MetaKey)
            {
                // Apple key was pressed - toggle the selection
                SelectionService.Instance.ToggleSelection(new List<Image> { image });
            }
            else
            {
                // No keys pressed. Select if unselected, or deselect if selected - but
                // clear any other selection at the same time. Store the last selection
                // as it could be the beginning of a range selection
                bool wasPreviouslySelected = SelectionService.Instance.IsSelected(image);
                SelectionService.Instance.ClearSelection();
                prevSelection = null;

                if (!wasPreviouslySelected)
                {
                    SelectionService.Instance.SelectImage(image);
                    prevSelection = image;
                }
            }
        }

        watch.Stop();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            basketService.OnChange += SelectedImagesChanged;
            await LoadData();
        }
    }

    public void Dispose()
    {
        basketService.OnChange -= SelectedImagesChanged;
    }

    protected void SelectedImagesChanged()
    {
        // Marshall onto the dispatcher thread
        _ = LoadData();
    }

    public async Task LoadData()
    {
        var watch = new Stopwatch("SelectedLoadData");
        images.Clear();
        images.AddRange( basketService.SelectedImages );
        watch.Stop();

        using var db = new ImageContext();
        // TODO: Do we need to load this every time?
        this.baskets.Clear();
        this.baskets.AddRange(db.Baskets);

        await InvokeAsync(StateHasChanged);
    }
}

